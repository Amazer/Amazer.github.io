---
title: '[引擎笔记]之三：处理重要窗口事件'
toc: true
copyright: true
date: 2018-04-13 14:12:45
tags: ['引擎笔记','笔记']
---
### 1.窗口事件
<!--more-->

#### 1.激活窗口消息


| 消息值 | 描述 |
|:-----|:---|
| WM_ACTIVATE | 某个窗口被激活或者取消激活时候触发。该消息首先传递到被撤销激活的最高级窗口的窗口程序中 |
| WM_ACTIVATEAPP | 当一个属于应用程序的非活动窗口正要被激活时，向被激活和被取消的窗口程序传递该消息 |

参数描述:

|参数|描述|
|:-----:|:---|
| msg |消息值|
|wparam |低字节：是否激活；  高字节：是否为最小化| 
|lparam|窗口句柄|

```
fActive = LOWORD(wParam);               // 状态：是否激活
fMinimized =(BOOL)HIWORD(wParam);       // 是否为最小化
hwndPrevious=(HWND)lparam;              // 上一个窗口
```

其中fActive参数的值为：

|值|描述|
|:---|:---|
|WA_CLICKACTIVE|通过鼠标单击激活了该窗口|
|WA_ACTIVE|通过鼠标以外的工具（比如键盘什么的）激活了该窗口
|WA_INACTIVE|取消该窗口的激活|


#### 2.关闭窗口消息


| 消息值 | 描述 |
|:-----|:---|
| WM_CLOSE  | 用户试图关闭窗口。在WM_DESTROY和WM_QUIT之前触发 |

参数: 无

#### 3.窗口大小改变消息


| 消息值 | 描述 |
|:-----|:---|
| WM_SIZE  | 窗口尺寸发生了变化 |

参数描述:

|参数|描述|
|:-----:|:---|
| msg |消息值|
|wparam |尺寸变化标记| 
|lparam|低字节：窗口的宽度；  高字节：窗口的高度|

```
fwSizeType = wParam;        // resizing flab
nWidth = LOWORD(lParam);    // width of client area
nHeight = HIWORD(lParam);   // height of client area
```


fwSizeType标记：

|值|描述|
|:---|:---|
|SIZE_MAXHIDE| 当某些窗口最大化时，该消息被发送往**所有的**弹出式窗口|
|SIZE_MAXIMIZED| 该窗口已最大化|
|SIZE_MAXSHOW| 当某些窗口恢复到之前的尺寸时，该消息被发送往**所有的**弹出式窗口|
|SIZE_MINIMIZED| 该窗口已最小化|
|SIZE_RESTORED| 窗口尺寸改变了，但不适用 SIZE_MINIMIZED 或 SIZE_MAXIMIZED|

**注意： 窗口尺寸变化会WM_PAINT事件也会触发**


#### 4.窗口移动消息

| 消息值 | 描述 |
|:-----|:---|
| WM_MOVE  | 窗口位置发生了变化之后触发 |
| WM_MOVING  | 窗口位置正在发生变化 |

参数描述:

|参数|描述|
|:-----:|:---|
| msg |消息值|
|lparam|低字节：水平方向的坐标(x)；  高字节：垂直方向的坐标(y)|

```
xPos = (int) LOWORD(lparam)
yPos = (int) HIWORD(lparam)
```

### 2.键盘事件

当按下键盘上某个键的时候，将产生两个数据：
- 扫描码（Scan Code）:唯一标识键盘上键的ID,eg.VK_SPACE(空格键)
- ASCII码: 按键所代表的字符，eg. a、A(shift和a同时按下的时候)、空格等
可以通过监听键盘事件，或者通过访问键盘的状态表来获取键的信息。

#### 1.WM_CHAR消息：

|事件值|描述|
|:---:|:---|
|WM_CHAR|按键后，获得ASCII码|

参数描述:

|参数|描述|
|:---:|:---|
|wparam|按下键的ASCII码|
|lparam|按位编码的状态矢量，描述可能被按下的特殊控制键。(p102详细内容)|

eg.
```
#define ALT_STATE_BIT 0x20000000
case WM_CHAR:
{
    int ascii_code = wparam;
    int key_state = lparam;

    if(key_state & ALT_STATE_BIT)
    {
        // alt键被按下
    }
}
break
```

#### 2.WM_KEYDOWN和WM_KEYUP消息：

消息中传递的是该键的虚拟扫描码。

|事件值|描述|
|:---:|:---|
|WM_KEYDOWN|键按下触发|
|WM_KEYUP|键抬起触发|

参数描述:

|参数|描述|
|:---:|:---|
|wparam|键的虚拟扫描码|
|lparam|按位编码的状态矢量，描述可能被按下的特殊控制键。(与WM_CHAR的状态不一样)(p104详细内容)|

eg.
```
case WM_KEYDOWN:
{
    int virtual_code = (int)wparam;
    int key_state = (int)lparam;

    switch(virtual_code)
    {
        case VK_RIGHT:{} break;         // 右箭头被按下
        case VK_LEFT:{} break;          // 左箭头被按下
        case VK_UP:{} break;            // 上箭头被按下
        case VK_DOWN:{} break;          // 下箭头被按下
        // .... 其他判断
    }
}
break
```

#### 3.GetAsyncKeyState():  调用查询键的状态的函数

该函数在键盘的状态中跟踪该键的最后已知状态。
访问键盘消息可以通过调用查询键盘状态的函数：
- GetKeyboardState()
- GetKeyState()
- **GetAsyncKeyState()**

GetAsyncKeyState()原型：
```
SHORT  GetAsyncKeyState(int virtual_key)
```
virtual_key：要查看的按键的虚拟键代码
如果返回值的最高位是1表示该键被按下，否则表示该键是松开的。
可以使用宏来定义键的按下和抬起：
```
#define KEYDOWN(vk_code) ((GetAsyncKeyState(vk_code)& 0x8000)? 1: 0)
#define KEYUP(vk_code) ((GetAsyncKeyState(vk_code)& 0x8000)? 0: 1)
```

**remark**:使用GetAsyncKeyState()的好处是，它和时间循环没有耦合关系，可以再任何地方测试按键。

举例代码：
```
if(KEYDOWN(VK_DOWN))
{
    // 按下了下箭头键
    // ...
}
```

### 3.鼠标事件

关于鼠标的消息有很多，这里只介绍WM_MOUSEMOVE和WM_\*BUTTON\*

#### 1.WM_MOUSEMOVE

1. 鼠标**位置**是相对于其所处于的**窗口用户区**而言的。也就是相对于窗口左上角(0,0)的坐标
2. 描述：

消息值：WM_MOUSEMOVE
参数：
lParam: 鼠标当前的坐标位置
wParam: 鼠标当前的按键编码
```
int mouse_x = (int) LOWORD(lParam)
int mouse_y = (int) HIWORD(lParam)

int buttons = (int)wParam;
```
<center>**WM_MOUSEMOVE按键编码**</center>

|值|描述|
|:---|:---|
|MK_LBUTTON|鼠标左键按下|
|MK_MBUTTON|鼠标中键按下|
|MK_RBUTTON|鼠标右键按下|
|MK_CONTROL|按下Ctrl键|
|MK_SHIFT|按下Shift键|

eg.
```
case WM_MOUSEMOVE
{
    int mouse_x = (int) LOWORD(lParam)
    int mouse_y = (int) HIWORD(lParam)

    int buttons = (int)wParam;

    if(buttons & MK_LBUTTON)
    {
        // 如果按下了鼠标左键
    }
    if(buttons & MK_RBUTTON & MK_SHIFT)
    {
        // 如果同时按下了鼠标右键和shift键
    }
    
}
```

#### 2.鼠标按键消息：WM_\*BUTTON\*

其他鼠标按键消息:
<center>**鼠标按键消息**</center>

|值|描述|
|:---|:---|
|WM_LBUTTONDBLCLK|鼠标左键双击|
|WM_LBUTTONDOWN|按下鼠标左键|
|WM_LBTTONUP|松开鼠标左键|
|WM_MBUTTONDBLCLK|鼠标中键双击|
|WM_MBUTTONDOWN|按下鼠标中键|
|WM_MBTTONUP|松开鼠标中键|
|WM_RBUTTONDBLCLK|鼠标右键双击|
|WM_RBUTTONDOWN|按下鼠标右键|
|WM_RBTTONUP|松开鼠标右键|
参数：
lParam: 鼠标位置信息
```
int mouse_x = (int) LOWORD(lParam)
int mouse_y = (int) HIWORD(lParam)
```
### 4.自定义发送消息

#### 1.发送消息

1.SendMessage()
SendMessage()向窗口传递一个要求**立即**处理的消息。接收窗口处理完该消息后，该函数紧接着WinProc()返回
实际上是调用WinProc()。
原型：
```
// 返回值是WinProc()的返回值
LRESULT SendMessage(HWND hWnd,      // 目标窗口
        UINT Msg,                   // 消息值
        WPARAM wParam,              
        LPARAM lParam)
        
```

2.PoseMessage()

PoseMessage()将消息发往窗口的**消息队列**，而后直接返回。如果不在意消息被处理以前的时间延迟，或者改消息的优先级较低，可以使用该函数。
实际上消息不经处理，直接进入消息队列。

```
// 如果执行成功，返回一个非0值
BOOL PoseMessage(HWND hWnd,      // 目标窗口
        UINT Msg,                   // 消息值
        WPARAM wParam,              
        LPARAM lParam);
```

例如,如果按下了esc键，发送关闭窗口的消息:

```
// 如果按下了esc键，发送关闭窗口的消息
if(KEYDOWN(VK_ESCAPE))
{
    SendMessage(hWnd,WM_CLOSE,0,0);
}   

```


#### 2.发送自定义消息:**WM_USER**

发送消息值为**WM_USER**的消息，任意设置wParam和lParam的值作为消息参数。
eg.

```
#define ALLOC_MEM     1000
#define DEALLOC_MEM   1001

// ....

SendMessage(hWnd,ALLOC_MEM,NULL);

// ...

case WM_USER:
{
    switch(wParam)
    {
        case ALLOC_MEM:
        //... 
        break;
        case DEALLOC_MEM:
        //... 
        break;

    }

}
```
